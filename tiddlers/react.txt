 * `<A /> === <A />` is false
 * `<A />` is `React.createElement(A)` and every time creates new object.
 * react elements are immutable.
 * `React.cloneElement( element, [props], [...children] )` is almost equivalent to: `<element.type {...element.props} {...props}>{children}</element.type>`
  * on functional component: if state is same. setting useState won't re-render. on class component, does re-render.
* `useEffect`: The one catch is that this runs after react renders your component and ensures that your   effect callback does not block browser painting. This differs from the behavior in class   components where componentDidMount and componentDidUpdate run synchronously   after rendering
* `useEffect` callback runs async, so itâ€™s not exactly like componentDidMount and componentDidUpdate. if you are updating DOM there, you might have flickering effect. then you using `useLayoutEffect` I guess.

!! useEffect with deep comparison
```
useEffect(() => {}, [x,y])
```
does simple reference equality check on x and y. if they are objects it won't work that much. to fix this we can use useEffect without providing variables and do the comparison inside the function. just we need previous values to compare and for that we can use useRef:

```
   function usePrev(values) { 
       const prev = React.useRef(); 
       useEffect(() => { prev.current = values; });
       return prev.current;
   }

   // inside the component
   useEffect(() => { if (_.isEqual([x,y], prev)) return; ... });
   const prev = usePrev([x,y]);
```

!! safe set when component is unmounted

if we have a request on fly, and component is unmounted, and the client requesting that call is not supporting cancelation, we need to avoid setState or set with hooks. then we can do this:

```
function useMounted() {
   const mounted = useRef(false);
   useEffect(() => { 
       mounted.current = true; 
       return () => { mounted.current = false; }
   }, []);
   return mounted;
}

function useSafeSet(initial) {
   const [state, setState] = useReducer((state, newState) => ({...state, ...newState}), initial);
   const mounted = useMounted();
   const safeSet = (...args) => mounted && setState(...args);
   return [state, safeSet];
}
```